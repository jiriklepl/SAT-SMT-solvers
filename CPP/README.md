# CDCL

The implementation can read a file in SATLIB or DIMACS format. It can deduce the format from the extension of the file name. The format can be enforced by using either `-c, --dimacs` option, or `-s, --satlib` options, this also allows the program to read from the standard input.

## Modes

- `ADJACENCY`: uses the DPLL algorithm with adjacency lists.
- `WATCHED`: uses the DPLL algorithm with watched literals (and stores clause literals in a contiguous manner).
- `WATCHED_SEP`: uses the DPLL algorithm with watched literals (and stores clauses separately).
- `CDCL_WATCHED`: uses the CDCL algorithm with watched literals and restarts after an amount of contradictions given by the luby sequence multiplied by the *unit run* variable.
- `CDCL_WATCHED_SEP`: uses the CDCL algorithm with watched literals, clauses stored separately, restarts after an amount of contradictions given by the luby sequence multiplied by the *unit run* variable, and removing a half of the learned clauses if the cache, initially set to the *cache limit* variable (the cache doubles after each removal wave), is full.

## Variables

- **unit run**: the multiplier used for computing the length of runs given by the luby sequence. The default value is `100`.
- **cache limit**: the initial size of cache for learned clauses. The default value is `10'000`.

## Build

The following command builds the release version of the CDCL program (`bin/main`):

```sh
make release
```

The following command will build the debug version of the CDCL program (`debug/main`) with extra assertions in the code ensuring the program works as intended and satisfies all invariants:

```sh
make debug
```

The following command builds the `formula2cnf` program:

```sh
make formula2cnf
```

## Run

The following command runs the CDCL program (the release version; change to `debug` or `profile` for the respective version of the program)

```sh
bin/main
```

To print out the help for the CDCL program:

```sh
bin/main --help
```

## Measuring

```sh
# prepare data
mkdir -p data
cd data
cat ../links.txt | while read link; do wget "$link"; done
for file in ./*.tar.gz; do tar -xzf $file; done
cd ..

# measure
./test.sh

# check validity
grep -qrE "^uf,[^,]*,[^,]*,0," out || echo "success" # satisfiable not identified as unsatisfiable
grep -qrE "^uuf,[^,]*,[^,]*,1," out || echo "success" # unsatisfiable not identified as satisfiable

# attempt to find a violation of program invariants
for i in data/UUF50.218.1000/*; do
  if (debug/main -u 1 -l 0 $i 2>&1 >/dev/null) | grep ".\+"; then
    echo $i
    break
  fi;
done

# check that the program does no illegal accesses
for i in data/UUF50.218.1000/*; do
  if ! valgrind --tool=memcheck bin/main -u 1 -l 0 $i 2>&1 >/dev/null | grep -q ": 0 errors"; then
    echo $i
    break
  fi;
done
```

## Aggregating the data

```sh
./script.R
```

## Results



## Tseitin Encoding and DIMACS Format

The implementation for this assignment, `formula2cnf`, built by `Makefile`, takes a formula in the SATLIB format and outputs in the DIMACS format.

It recognized the option `-e` (or `--equiv`) if the user requires using equivalence in the Tseitin encoding.

The output is as requested with comments giving detailed description of the structure:

- the first line contains the source file of the formula
- then follows the list of variables
- and then the list of all gates
- the last comment contains the root of the structure


## DPLL Algorithm &  Watched Literals

The implementation can read a file in SATLIB or DIMACS format. It can deduce the format from the extension of the file name or the format can be specified by either `-c, --dimacs` option or `-s, --satlib` option.

By default, it will use the version of the algorithm with watched literals, this can be changed to the version with adjacency lists by using the `-a, --adjacency` option.

And it also supports the `-e, --equiv` option from the `formula2cnf` program.

## Comparison of watched literals and adjacency lists

The two version of the program were tested using [RND3SAT](https://www.cs.ubc.ca/~hoos/SATLIB/Benchmarks/SAT/RND3SAT/descr.html) uf test sets with 20, 50, and 100 variables (see [links.txt](links.txt)) by the `test.sh` script. And then analyzed by the  `script.R` R script.

The conclusion is that the 'watched literals' version offers almost 50% mean speedup while preserving the number of decisions and the number of derivation performed while finding the model.

Here is the relative mean comparison generated by the R script (watched literals speedup compared to adjacency lists):

```
  variables     time decisions derivations
1        20 1.258361 1.0003466   1.0009109
2        50 1.560218 0.9664431   0.9666468
3       100 1.568032 0.9575588   0.9584289
```
